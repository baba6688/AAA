"""
自动装配工厂
负责创建和管理组件实例，支持依赖注入、单例管理、循环依赖检测和生命周期管理
提供完整的实例创建、缓存、销毁和监控功能
"""

import os
import inspect
import logging
import threading
import time
import weakref
from typing import Dict, Any, Optional, Type, List, Set, Callable, Union
from enum import Enum
from dataclasses import dataclass, asdict
from threading import RLock
from collections import defaultdict, OrderedDict
import hashlib
import json

class InstanceScope(Enum):
    """实例作用域枚举"""
    SINGLETON = "singleton"      # 单例，全局唯一实例
    TRANSIENT = "transient"      # 瞬时，每次创建新实例
    SCOPED = "scoped"            # 作用域，在同一作用域内唯一
    THREAD = "thread"            # 线程局部，每个线程唯一实例

class InstanceStatus(Enum):
    """实例状态枚举"""
    CREATED = "created"          # 已创建
    INITIALIZING = "initializing" # 初始化中
    INITIALIZED = "initialized"  # 已初始化
    ACTIVE = "active"            # 活跃
    SUSPENDED = "suspended"      # 挂起
    DESTROYING = "destroying"    # 销毁中
    DESTROYED = "destroyed"      # 已销毁
    ERROR = "error"              # 错误

@dataclass
class InstanceInfo:
    """实例信息数据类"""
    instance_id: str
    class_name: str
    instance: Any
    scope: InstanceScope
    status: InstanceStatus
    creation_time: float
    initialization_time: Optional[float]
    last_access_time: float
    access_count: int
    dependencies: List[str]
    metadata: Dict[str, Any]
    context: Optional[str]

@dataclass
class FactoryMetrics:
    """工厂指标数据类"""
    total_instances_created: int
    total_instances_destroyed: int
    active_instances: int
    singleton_instances: int
    transient_instances: int
    scoped_instances: int
    thread_instances: int
    cache_hit_rate: float
    average_creation_time: float
    total_creation_time: float
    dependency_resolution_time: float
    circular_dependency_detections: int

class AutoWiringFactory:
    """自动装配工厂 - 生产环境级别实现"""
    
    def __init__(self, registry, dependency_resolver, config_manager=None):
        self.registry = registry
        self.dependency_resolver = dependency_resolver
        self.config_manager = config_manager
        
        # 实例存储
        self._singleton_instances = OrderedDict()  # 单例实例缓存
        self._scoped_instances = defaultdict(OrderedDict)  # 作用域实例缓存
        self._thread_instances = defaultdict(OrderedDict)  # 线程实例缓存
        self._prototype_cache = {}  # 原型实例缓存（用于依赖解析期间）
        
        # 实例信息跟踪
        self._instance_info = {}  # 实例ID -> InstanceInfo
        self._class_instances = defaultdict(list)  # 类名 -> 实例ID列表
        
        # 状态管理
        self._creating_stack = set()  # 正在创建的实例栈（用于检测循环依赖）
        self._instance_lock = RLock()  # 线程安全锁
        self._context_lock = defaultdict(RLock)  # 上下文级别锁
        
        # 生命周期管理
        self._pre_creation_callbacks = []
        self._post_creation_callbacks = []
        self._pre_destruction_callbacks = []
        self._post_destruction_callbacks = []
        self._error_handlers = []
        
        # 配置
        self.auto_wire_enabled = True
        self.singleton_by_default = True
        self.enable_lazy_loading = True
        self.enable_circular_dependency_detection = True
        self.circular_dependency_timeout = 30.0
        self.max_creation_depth = 10
        self.default_scope = InstanceScope.SINGLETON
        
        # 性能监控
        self._metrics = FactoryMetrics(
            total_instances_created=0,
            total_instances_destroyed=0,
            active_instances=0,
            singleton_instances=0,
            transient_instances=0,
            scoped_instances=0,
            thread_instances=0,
            cache_hit_rate=0.0,
            average_creation_time=0.0,
            total_creation_time=0.0,
            dependency_resolution_time=0.0,
            circular_dependency_detections=0
        )
        
        # 上下文管理
        self._current_context = "default"
        self._context_chain = ["default"]
        
        # 垃圾回收辅助
        self._weak_refs = weakref.WeakValueDictionary()
        
        # 日志
        self.logger = logging.getLogger('AOO.Factory')
        
        # 初始化
        self._load_config()
    
    def _load_config(self):
        """加载配置"""
        if self.config_manager:
            try:
                factory_config = self.config_manager.get_section('factory') or {}
                self.auto_wire_enabled = factory_config.get('auto_wire_enabled', True)
                self.singleton_by_default = factory_config.get('singleton_by_default', True)
                self.enable_lazy_loading = factory_config.get('enable_lazy_loading', True)
                self.enable_circular_dependency_detection = factory_config.get(
                    'enable_circular_dependency_detection', True)
                self.circular_dependency_timeout = factory_config.get('circular_dependency_timeout', 30.0)
                self.max_creation_depth = factory_config.get('max_creation_depth', 10)
                
                scope_str = factory_config.get('default_scope', 'singleton')
                self.default_scope = InstanceScope(scope_str)
            except Exception as e:
                self.logger.warning(f"加载工厂配置失败: {e}")
    
    def create_instance(self, 
                       class_name: str, 
                       scope: InstanceScope = None,
                       context: str = None,
                       use_singleton: bool = None,
                       **kwargs) -> Any:
        """
        创建类的实例，自动注入依赖
        
        Args:
            class_name: 要创建的类名
            scope: 实例作用域
            context: 上下文标识
            use_singleton: 是否使用单例模式（兼容参数）
            **kwargs: 直接传递的参数，会覆盖自动注入
        
        Returns:
            创建的实例
            
        Raises:
            ValueError: 类未找到
            RuntimeError: 创建实例失败或循环依赖
        """
        # 参数处理
        if use_singleton is not None:
            scope = InstanceScope.SINGLETON if use_singleton else InstanceScope.TRANSIENT
        elif scope is None:
            scope = self.default_scope
        
        if context is None:
            context = self._current_context
        
        start_time = time.time()
        
        try:
            # 检查缓存（针对单例和作用域实例）
            cached_instance = self._get_cached_instance(class_name, scope, context)
            if cached_instance is not None:
                self._update_access_stats(cached_instance)
                return cached_instance
            
            # 获取类信息
            class_info = self.registry.get_class(class_name)
            if not class_info:
                raise ValueError(f"类未找到: {class_name}")
            
            cls = class_info.get('class_object')
            if not cls:
                raise ValueError(f"无法获取类对象: {class_name}")
            
            # 检测循环依赖
            if self.enable_circular_dependency_detection:
                self._check_circular_dependency(class_name)
            
            # 生成实例ID
            instance_id = self._generate_instance_id(class_name, scope, context)
            
            # 执行预创建回调
            creation_context = {
                'class_name': class_name,
                'class_info': class_info,
                'scope': scope,
                'context': context,
                'instance_id': instance_id,
                'kwargs': kwargs.copy()
            }
            self._execute_pre_creation_callbacks(creation_context)
            
            # 解析依赖
            dependency_start = time.time()
            dependencies = self._resolve_dependencies(class_name, class_info, context)
            self._metrics.dependency_resolution_time += time.time() - dependency_start
            
            # 准备构造函数参数
            constructor_args = self._prepare_constructor_args(cls, dependencies, kwargs, class_info)
            
            # 创建实例
            instance = self._instantiate_class(cls, constructor_args, class_name)
            
            # 初始化实例
            self._initialize_instance(instance, instance_id, class_name, class_info, scope, context)
            
            # 缓存实例
            self._cache_instance(instance, instance_id, class_name, scope, context, dependencies)
            
            # 更新指标
            creation_time = time.time() - start_time
            self._update_creation_metrics(creation_time)
            
            # 执行后创建回调
            self._execute_post_creation_callbacks(instance, creation_context)
            
            self.logger.debug(f"成功创建实例: {class_name} (scope: {scope.value}, context: {context})")
            return instance
            
        except Exception as e:
            creation_time = time.time() - start_time
            self._update_error_metrics(creation_time)
            
            # 执行错误处理回调
            error_context = {
                'class_name': class_name,
                'scope': scope,
                'context': context,
                'error': e,
                'creation_time': creation_time
            }
            self._execute_error_handlers(error_context)
            
            self.logger.error(f"创建实例失败 {class_name}: {str(e)}")
            raise RuntimeError(f"创建实例失败 {class_name}: {str(e)}")
        
        finally:
            # 清理创建栈
            self._creating_stack.discard(class_name)
    
    def _get_cached_instance(self, class_name: str, scope: InstanceScope, context: str) -> Optional[Any]:
        """获取缓存的实例"""
        instance_id = self._generate_instance_id(class_name, scope, context)
        
        if scope == InstanceScope.SINGLETON:
            with self._instance_lock:
                if instance_id in self._singleton_instances:
                    self._metrics.cache_hit_rate = (
                        (self._metrics.cache_hit_rate * self._metrics.total_instances_created + 1) /
                        (self._metrics.total_instances_created + 1)
                    )
                    return self._singleton_instances[instance_id]
        
        elif scope == InstanceScope.SCOPED:
            with self._context_lock[context]:
                if instance_id in self._scoped_instances[context]:
                    self._metrics.cache_hit_rate = (
                        (self._metrics.cache_hit_rate * self._metrics.total_instances_created + 1) /
                        (self._metrics.total_instances_created + 1)
                    )
                    return self._scoped_instances[context][instance_id]
        
        elif scope == InstanceScope.THREAD:
            thread_id = threading.current_thread().ident
            with self._instance_lock:
                if thread_id in self._thread_instances and instance_id in self._thread_instances[thread_id]:
                    self._metrics.cache_hit_rate = (
                        (self._metrics.cache_hit_rate * self._metrics.total_instances_created + 1) /
                        (self._metrics.total_instances_created + 1)
                    )
                    return self._thread_instances[thread_id][instance_id]
        
        return None
    
    def _check_circular_dependency(self, class_name: str):
        """检查循环依赖"""
        if class_name in self._creating_stack:
            self._metrics.circular_dependency_detections += 1
            dependency_chain = " -> ".join(self._creating_stack) + f" -> {class_name}"
            raise RuntimeError(f"检测到循环依赖: {dependency_chain}")
        
        # 检查创建栈深度
        if len(self._creating_stack) >= self.max_creation_depth:
            raise RuntimeError(f"达到最大创建深度: {self.max_creation_depth}")
        
        # 添加到创建栈
        self._creating_stack.add(class_name)
    
    def _resolve_dependencies(self, class_name: str, class_info: Dict[str, Any], context: str) -> List[Dict[str, Any]]:
        """解析依赖关系"""
        if not self.auto_wire_enabled:
            return []
        
        # 使用依赖解析器解析依赖
        resolution_results = self.dependency_resolver.resolve_dependencies(class_name)
        
        dependencies = []
        for result in resolution_results:
            if result.status.name == "RESOLVED" and result.selected:
                try:
                    # 递归创建依赖实例（使用原型模式避免循环依赖）
                    dep_instance = self._create_dependency_instance(result.selected, context)
                    
                    dependencies.append({
                        'name': result.node.name,
                        'class_name': result.selected,
                        'instance': dep_instance,
                        'node': result.node,
                        'result': result
                    })
                except Exception as e:
                    self.logger.warning(f"创建依赖实例失败 {result.selected} for {class_name}: {e}")
                    if result.node.required:
                        raise
        
        return dependencies
    
    def _create_dependency_instance(self, class_name: str, context: str) -> Any:
        """创建依赖实例（使用原型模式）"""
        # 检查原型缓存
        cache_key = f"{class_name}_{context}"
        if cache_key in self._prototype_cache:
            return self._prototype_cache[cache_key]
        
        # 使用原型模式创建依赖实例
        instance = self.create_instance(
            class_name,
            scope=InstanceScope.TRANSIENT,  # 依赖使用瞬时模式
            context=context,
            use_singleton=False
        )
        
        # 缓存原型实例（弱引用）
        self._prototype_cache[cache_key] = instance
        return instance
    
    def _prepare_constructor_args(self, 
                                 cls: Type, 
                                 dependencies: List[Dict], 
                                 kwargs: Dict, 
                                 class_info: Dict[str, Any]) -> Dict[str, Any]:
        """准备构造函数参数"""
        constructor_args = {}
        
        # 获取构造函数签名
        init_signature = self._get_constructor_signature(cls)
        
        # 注入配置
        config_args = self._inject_configuration(cls, init_signature, class_info)
        constructor_args.update(config_args)
        
        # 注入依赖实例
        dependency_args = self._inject_dependencies(dependencies, init_signature)
        constructor_args.update(dependency_args)
        
        # 添加显式传递的参数（优先级最高）
        valid_kwargs = self._filter_valid_parameters(init_signature, kwargs)
        constructor_args.update(valid_kwargs)
        
        # 验证必需参数
        self._validate_required_parameters(init_signature, constructor_args, cls.__name__)
        
        return constructor_args
    
    def _get_constructor_signature(self, cls: Type) -> inspect.Signature:
        """获取构造函数签名"""
        try:
            if hasattr(cls, '__init__'):
                return inspect.signature(cls.__init__)
        except (ValueError, TypeError):
            pass
        return inspect.Signature()
    
    def _inject_configuration(self, cls: Type, signature: inspect.Signature, class_info: Dict[str, Any]) -> Dict[str, Any]:
        """注入配置参数"""
        config_args = {}
        
        if not self.config_manager:
            return config_args
        
        # 检查配置参数
        for param_name, param in signature.parameters.items():
            if param_name in ['self', 'args', 'kwargs']:
                continue
                
            # 检查参数名是否与配置相关
            if param_name in ['config', 'configuration', 'settings']:
                # 获取配置章节
                config_section = None
                if hasattr(cls, 'get_config_section'):
                    try:
                        config_section = cls.get_config_section()
                    except:
                        pass
                
                if not config_section:
                    # 使用类名作为默认配置章节
                    config_section = class_info.get('class_name', cls.__name__).lower()
                
                # 获取配置
                config_data = self.config_manager.get_section(config_section)
                if config_data:
                    config_args[param_name] = config_data
                else:
                    # 注入空配置
                    config_args[param_name] = {}
        
        return config_args
    
    def _inject_dependencies(self, dependencies: List[Dict], signature: inspect.Signature) -> Dict[str, Any]:
        """注入依赖实例"""
        dependency_args = {}
        
        for dep in dependencies:
            dep_name = dep['name']
            dep_instance = dep['instance']
            
            # 查找匹配的参数名
            param_name = self._find_matching_parameter(dep_name, dep['node'], signature)
            if param_name:
                dependency_args[param_name] = dep_instance
            else:
                # 如果没有明确匹配，使用类名的蛇形命名
                snake_name = self._camel_to_snake(dep['class_name'])
                if snake_name in signature.parameters:
                    dependency_args[snake_name] = dep_instance
        
        return dependency_args
    
    def _find_matching_parameter(self, dep_name: str, node: Any, signature: inspect.Signature) -> Optional[str]:
        """查找匹配的参数名"""
        # 精确匹配
        if dep_name in signature.parameters:
            return dep_name
        
        # 类型注解匹配
        for param_name, param in signature.parameters.items():
            if param.annotation != inspect.Parameter.empty:
                annotation_name = self._get_annotation_name(param.annotation)
                if (annotation_name and 
                    node.interface and 
                    annotation_name == node.interface):
                    return param_name
        
        # 名称推断匹配
        snake_name = self._camel_to_snake(dep_name)
        if snake_name in signature.parameters:
            return snake_name
        
        return None
    
    def _camel_to_snake(self, name: str) -> str:
        """驼峰命名转蛇形命名"""
        if not name:
            return name
        
        result = [name[0].lower()]
        for char in name[1:]:
            if char.isupper():
                result.append('_')
            result.append(char.lower())
        return ''.join(result)
    
    def _get_annotation_name(self, annotation) -> str:
        """从类型注解中提取类名"""
        if hasattr(annotation, '__name__'):
            return annotation.__name__
        elif hasattr(annotation, '_name'):
            return annotation._name
        elif hasattr(annotation, '__origin__'):
            # 处理泛型类型
            origin = annotation.__origin__
            if hasattr(origin, '__name__'):
                return origin.__name__
        return str(annotation)
    
    def _filter_valid_parameters(self, signature: inspect.Signature, provided_args: Dict) -> Dict[str, Any]:
        """过滤有效的参数"""
        valid_args = {}
        
        for param_name, param in signature.parameters.items():
            if param_name in ['self', 'args', 'kwargs']:
                continue
            
            if param_name in provided_args:
                valid_args[param_name] = provided_args[param_name]
            elif param.kind == param.VAR_KEYWORD:
                # 处理 **kwargs - 注入所有额外参数
                valid_args.update(provided_args)
        
        return valid_args
    
    def _validate_required_parameters(self, signature: inspect.Signature, provided_args: Dict, class_name: str):
        """验证必需参数"""
        for param_name, param in signature.parameters.items():
            if (param_name not in ['self', 'args', 'kwargs'] and 
                param.default == inspect.Parameter.empty and
                param.kind not in [param.VAR_POSITIONAL, param.VAR_KEYWORD] and
                param_name not in provided_args):
                raise ValueError(f"缺少必需参数: {class_name}.__init__() 需要参数 '{param_name}'")
    
    def _instantiate_class(self, cls: Type, constructor_args: Dict, class_name: str) -> Any:
        """实例化类"""
        try:
            return cls(**constructor_args)
        except TypeError as e:
            # 参数不匹配，尝试最小化参数集
            self.logger.warning(f"参数不匹配 {class_name}, 尝试最小参数集: {e}")
            minimal_args = self._create_minimal_arguments(cls, constructor_args)
            return cls(**minimal_args)
        except Exception as e:
            self.logger.error(f"实例化类失败 {class_name}: {e}")
            raise
    
    def _create_minimal_arguments(self, cls: Type, constructor_args: Dict) -> Dict[str, Any]:
        """创建最小参数集"""
        minimal_args = {}
        signature = self._get_constructor_signature(cls)
        
        for param_name, param in signature.parameters.items():
            if param_name in ['self', 'args', 'kwargs']:
                continue
                
            if param_name in constructor_args:
                minimal_args[param_name] = constructor_args[param_name]
            elif param.default != inspect.Parameter.empty:
                # 有默认值，跳过
                pass
            elif param.kind == param.VAR_KEYWORD:
                # 注入所有额外参数
                minimal_args.update(constructor_args)
        
        return minimal_args
    
    def _initialize_instance(self, 
                           instance: Any, 
                           instance_id: str, 
                           class_name: str,
                           class_info: Dict[str, Any],
                           scope: InstanceScope,
                           context: str):
        """初始化实例"""
        # 设置实例基本信息
        if hasattr(instance, '_instance_id'):
            instance._instance_id = instance_id
        if hasattr(instance, '_scope'):
            instance._scope = scope
        if hasattr(instance, '_context'):
            instance._context = context
        
        # 调用初始化方法（如果存在）
        if hasattr(instance, 'initialize'):
            try:
                instance.initialize()
            except Exception as e:
                self.logger.warning(f"实例初始化方法调用失败 {class_name}: {e}")
    
    def _cache_instance(self, 
                       instance: Any, 
                       instance_id: str, 
                       class_name: str,
                       scope: InstanceScope,
                       context: str,
                       dependencies: List[Dict]):
        """缓存实例"""
        # 创建实例信息
        dependency_ids = [dep['class_name'] for dep in dependencies]
        instance_info = InstanceInfo(
            instance_id=instance_id,
            class_name=class_name,
            instance=instance,
            scope=scope,
            status=InstanceStatus.ACTIVE,
            creation_time=time.time(),
            initialization_time=time.time(),
            last_access_time=time.time(),
            access_count=1,
            dependencies=dependency_ids,
            metadata={},
            context=context
        )
        
        # 存储实例信息
        with self._instance_lock:
            self._instance_info[instance_id] = instance_info
            self._class_instances[class_name].append(instance_id)
            
            # 根据作用域缓存实例
            if scope == InstanceScope.SINGLETON:
                self._singleton_instances[instance_id] = instance
                self._metrics.singleton_instances += 1
            elif scope == InstanceScope.SCOPED:
                with self._context_lock[context]:
                    self._scoped_instances[context][instance_id] = instance
                    self._metrics.scoped_instances += 1
            elif scope == InstanceScope.THREAD:
                thread_id = threading.current_thread().ident
                self._thread_instances[thread_id][instance_id] = instance
                self._metrics.thread_instances += 1
            else:  # TRANSIENT
                self._metrics.transient_instances += 1
            
            self._metrics.active_instances += 1
            self._metrics.total_instances_created += 1
    
    def _generate_instance_id(self, class_name: str, scope: InstanceScope, context: str) -> str:
        """生成实例ID"""
        base_id = f"{class_name}_{scope.value}_{context}"
        return hashlib.md5(base_id.encode()).hexdigest()[:16]
    
    def _update_access_stats(self, instance: Any):
        """更新访问统计"""
        # 这里需要根据实例找到对应的InstanceInfo并更新
        # 简化实现：在实际系统中需要完善
        pass
    
    def _update_creation_metrics(self, creation_time: float):
        """更新创建指标"""
        self._metrics.total_creation_time += creation_time
        self._metrics.average_creation_time = (
            self._metrics.total_creation_time / self._metrics.total_instances_created
        )
    
    def _update_error_metrics(self, creation_time: float):
        """更新错误指标"""
        # 错误情况下也记录时间，但不算入成功创建
        self._metrics.total_creation_time += creation_time
    
    def _execute_pre_creation_callbacks(self, context: Dict[str, Any]):
        """执行预创建回调"""
        for callback in self._pre_creation_callbacks:
            try:
                callback(context)
            except Exception as e:
                self.logger.error(f"预创建回调执行失败: {e}")
    
    def _execute_post_creation_callbacks(self, instance: Any, context: Dict[str, Any]):
        """执行后创建回调"""
        for callback in self._post_creation_callbacks:
            try:
                callback(instance, context)
            except Exception as e:
                self.logger.error(f"后创建回调执行失败: {e}")
    
    def _execute_error_handlers(self, context: Dict[str, Any]):
        """执行错误处理回调"""
        for handler in self._error_handlers:
            try:
                handler(context)
            except Exception as e:
                self.logger.error(f"错误处理回调执行失败: {e}")
    
    def get_instance(self, class_name: str, context: str = None) -> Any:
        """获取实例（优先使用单例）"""
        if context is None:
            context = self._current_context
        
        # 按作用域优先级查找实例
        scopes_to_try = [
            InstanceScope.SINGLETON,
            InstanceScope.SCOPED,
            InstanceScope.THREAD,
            InstanceScope.TRANSIENT
        ]
        
        for scope in scopes_to_try:
            instance = self._get_cached_instance(class_name, scope, context)
            if instance is not None:
                return instance
        
        # 没有找到现有实例，创建新实例
        return self.create_instance(class_name, context=context)
    
    def get_singleton(self, class_name: str) -> Any:
        """获取单例实例"""
        return self.create_instance(class_name, scope=InstanceScope.SINGLETON)
    
    def get_scoped_instance(self, class_name: str, context: str = None) -> Any:
        """获取作用域实例"""
        if context is None:
            context = self._current_context
        return self.create_instance(class_name, scope=InstanceScope.SCOPED, context=context)
    
    def get_thread_instance(self, class_name: str) -> Any:
        """获取线程实例"""
        return self.create_instance(class_name, scope=InstanceScope.THREAD)
    
    def get_transient_instance(self, class_name: str) -> Any:
        """获取瞬时实例"""
        return self.create_instance(class_name, scope=InstanceScope.TRANSIENT)
    
    def register_instance(self, class_name: str, instance: Any, scope: InstanceScope = None, context: str = None):
        """注册现有实例"""
        if scope is None:
            scope = self.default_scope
        if context is None:
            context = self._current_context
        
        instance_id = self._generate_instance_id(class_name, scope, context)
        
        # 创建实例信息
        instance_info = InstanceInfo(
            instance_id=instance_id,
            class_name=class_name,
            instance=instance,
            scope=scope,
            status=InstanceStatus.ACTIVE,
            creation_time=time.time(),
            initialization_time=time.time(),
            last_access_time=time.time(),
            access_count=0,
            dependencies=[],
            metadata={},
            context=context
        )
        
        # 缓存实例
        with self._instance_lock:
            self._instance_info[instance_id] = instance_info
            self._class_instances[class_name].append(instance_id)
            
            if scope == InstanceScope.SINGLETON:
                self._singleton_instances[instance_id] = instance
                self._metrics.singleton_instances += 1
            elif scope == InstanceScope.SCOPED:
                with self._context_lock[context]:
                    self._scoped_instances[context][instance_id] = instance
                    self._metrics.scoped_instances += 1
            elif scope == InstanceScope.THREAD:
                thread_id = threading.current_thread().ident
                self._thread_instances[thread_id][instance_id] = instance
                self._metrics.thread_instances += 1
            
            self._metrics.active_instances += 1
            self._metrics.total_instances_created += 1
    
    def destroy_instance(self, instance_id: str):
        """销毁指定实例"""
        with self._instance_lock:
            if instance_id not in self._instance_info:
                return False
            
            instance_info = self._instance_info[instance_id]
            instance = instance_info.instance
            
            # 执行预销毁回调
            destruction_context = {
                'instance_id': instance_id,
                'class_name': instance_info.class_name,
                'scope': instance_info.scope,
                'context': instance_info.context
            }
            self._execute_pre_destruction_callbacks(instance, destruction_context)
            
            # 更新状态
            instance_info.status = InstanceStatus.DESTROYING
            
            # 调用销毁方法（如果存在）
            if hasattr(instance, 'destroy'):
                try:
                    instance.destroy()
                except Exception as e:
                    self.logger.warning(f"实例销毁方法调用失败 {instance_info.class_name}: {e}")
            
            # 从缓存中移除
            if instance_info.scope == InstanceScope.SINGLETON:
                if instance_id in self._singleton_instances:
                    del self._singleton_instances[instance_id]
                    self._metrics.singleton_instances -= 1
            elif instance_info.scope == InstanceScope.SCOPED:
                context = instance_info.context
                if context in self._scoped_instances and instance_id in self._scoped_instances[context]:
                    del self._scoped_instances[context][instance_id]
                    self._metrics.scoped_instances -= 1
            elif instance_info.scope == InstanceScope.THREAD:
                for thread_id in list(self._thread_instances.keys()):
                    if instance_id in self._thread_instances[thread_id]:
                        del self._thread_instances[thread_id][instance_id]
                        self._metrics.thread_instances -= 1
            
            # 更新实例信息
            instance_info.status = InstanceStatus.DESTROYED
            
            # 从类实例索引中移除
            class_name = instance_info.class_name
            if class_name in self._class_instances and instance_id in self._class_instances[class_name]:
                self._class_instances[class_name].remove(instance_id)
            
            # 从主信息存储中移除
            del self._instance_info[instance_id]
            
            # 更新指标
            self._metrics.active_instances -= 1
            self._metrics.total_instances_destroyed += 1
            
            # 执行后销毁回调
            self._execute_post_destruction_callbacks(instance_info, destruction_context)
            
            self.logger.info(f"实例销毁成功: {instance_id}")
            return True
    
    def destroy_instances_by_class(self, class_name: str):
        """销毁指定类的所有实例"""
        with self._instance_lock:
            if class_name not in self._class_instances:
                return 0
            
            instance_ids = self._class_instances[class_name].copy()
            destroyed_count = 0
            
            for instance_id in instance_ids:
                if self.destroy_instance(instance_id):
                    destroyed_count += 1
            
            return destroyed_count
    
    def destroy_instances_by_context(self, context: str):
        """销毁指定上下文的所有实例"""
        with self._instance_lock:
            destroyed_count = 0
            
            # 查找属于该上下文的所有实例
            instance_ids_to_destroy = []
            for instance_id, instance_info in self._instance_info.items():
                if instance_info.context == context:
                    instance_ids_to_destroy.append(instance_id)
            
            # 销毁实例
            for instance_id in instance_ids_to_destroy:
                if self.destroy_instance(instance_id):
                    destroyed_count += 1
            
            return destroyed_count
    
    def clear_context(self, context: str):
        """清空指定上下文的所有实例"""
        return self.destroy_instances_by_context(context)
    
    def enter_context(self, context: str):
        """进入上下文"""
        self._context_chain.append(context)
        self._current_context = context
        self.logger.debug(f"进入上下文: {context}")
    
    def exit_context(self):
        """退出当前上下文"""
        if len(self._context_chain) <= 1:
            self.logger.warning("无法退出默认上下文")
            return
        
        old_context = self._context_chain.pop()
        self._current_context = self._context_chain[-1]
        self.logger.debug(f"退出上下文: {old_context} -> {self._current_context}")
    
    def get_current_context(self) -> str:
        """获取当前上下文"""
        return self._current_context
    
    def get_context_chain(self) -> List[str]:
        """获取上下文链"""
        return self._context_chain.copy()
    
    def add_pre_creation_callback(self, callback: Callable):
        """添加预创建回调"""
        self._pre_creation_callbacks.append(callback)
    
    def add_post_creation_callback(self, callback: Callable):
        """添加后创建回调"""
        self._post_creation_callbacks.append(callback)
    
    def add_pre_destruction_callback(self, callback: Callable):
        """添加预销毁回调"""
        self._pre_destruction_callbacks.append(callback)
    
    def add_post_destruction_callback(self, callback: Callable):
        """添加后销毁回调"""
        self._post_destruction_callbacks.append(callback)
    
    def add_error_handler(self, handler: Callable):
        """添加错误处理回调"""
        self._error_handlers.append(handler)
    
    def _execute_pre_destruction_callbacks(self, instance: Any, context: Dict[str, Any]):
        """执行预销毁回调"""
        for callback in self._pre_destruction_callbacks:
            try:
                callback(instance, context)
            except Exception as e:
                self.logger.error(f"预销毁回调执行失败: {e}")
    
    def _execute_post_destruction_callbacks(self, instance_info: InstanceInfo, context: Dict[str, Any]):
        """执行后销毁回调"""
        for callback in self._post_destruction_callbacks:
            try:
                callback(instance_info, context)
            except Exception as e:
                self.logger.error(f"后销毁回调执行失败: {e}")
    
    def get_instance_info(self, instance_id: str) -> Optional[InstanceInfo]:
        """获取实例信息"""
        with self._instance_lock:
            return self._instance_info.get(instance_id)
    
    def get_instances_by_class(self, class_name: str) -> List[InstanceInfo]:
        """获取指定类的所有实例信息"""
        with self._instance_lock:
            if class_name not in self._class_instances:
                return []
            
            instance_infos = []
            for instance_id in self._class_instances[class_name]:
                if instance_id in self._instance_info:
                    instance_infos.append(self._instance_info[instance_id])
            
            return instance_infos
    
    def get_instances_by_context(self, context: str) -> List[InstanceInfo]:
        """获取指定上下文的所有实例信息"""
        with self._instance_lock:
            instance_infos = []
            for instance_id, instance_info in self._instance_info.items():
                if instance_info.context == context:
                    instance_infos.append(instance_info)
            
            return instance_infos
    
    def get_metrics(self) -> FactoryMetrics:
        """获取工厂指标"""
        return self._metrics
    
    def get_statistics(self) -> Dict[str, Any]:
        """获取统计信息"""
        uptime = time.time() - getattr(self, '_start_time', time.time())
        
        return {
            'instances': {
                'total_created': self._metrics.total_instances_created,
                'total_destroyed': self._metrics.total_instances_destroyed,
                'active': self._metrics.active_instances,
                'singleton': self._metrics.singleton_instances,
                'transient': self._metrics.transient_instances,
                'scoped': self._metrics.scoped_instances,
                'thread': self._metrics.thread_instances
            },
            'performance': {
                'cache_hit_rate': self._metrics.cache_hit_rate,
                'average_creation_time': self._metrics.average_creation_time,
                'total_creation_time': self._metrics.total_creation_time,
                'dependency_resolution_time': self._metrics.dependency_resolution_time,
                'circular_dependency_detections': self._metrics.circular_dependency_detections
            },
            'contexts': {
                'current': self._current_context,
                'chain': self._context_chain,
                'scoped_instances_count': len(self._scoped_instances),
                'thread_instances_count': len(self._thread_instances)
            },
            'operations': {
                'pre_creation_callbacks': len(self._pre_creation_callbacks),
                'post_creation_callbacks': len(self._post_creation_callbacks),
                'pre_destruction_callbacks': len(self._pre_destruction_callbacks),
                'post_destruction_callbacks': len(self._post_destruction_callbacks),
                'error_handlers': len(self._error_handlers)
            }
        }
    
    def clear_cache(self):
        """清空缓存"""
        with self._instance_lock:
            self._singleton_instances.clear()
            self._scoped_instances.clear()
            self._thread_instances.clear()
            self._prototype_cache.clear()
            self._instance_info.clear()
            self._class_instances.clear()
            self._creating_stack.clear()
            
            # 重置指标
            self._metrics.active_instances = 0
            self._metrics.singleton_instances = 0
            self._metrics.transient_instances = 0
            self._metrics.scoped_instances = 0
            self._metrics.thread_instances = 0
            
            self.logger.info("工厂缓存已清空")
    
    def shutdown(self):
        """关闭工厂，销毁所有实例"""
        with self._instance_lock:
            # 销毁所有实例
            instance_ids = list(self._instance_info.keys())
            for instance_id in instance_ids:
                self.destroy_instance(instance_id)
            
            # 清空回调
            self._pre_creation_callbacks.clear()
            self._post_creation_callbacks.clear()
            self._pre_destruction_callbacks.clear()
            self._post_destruction_callbacks.clear()
            self._error_handlers.clear()
            
            self.logger.info("自动装配工厂已关闭")


class FactoryBuilder:
    """工厂构建器，用于配置和创建工厂"""
    
    def __init__(self):
        self._config = {
            'auto_wire_enabled': True,
            'singleton_by_default': True,
            'enable_lazy_loading': True,
            'enable_circular_dependency_detection': True,
            'circular_dependency_timeout': 30.0,
            'max_creation_depth': 10,
            'default_scope': InstanceScope.SINGLETON
        }
        self._callbacks = {
            'pre_creation': [],
            'post_creation': [],
            'pre_destruction': [],
            'post_destruction': [],
            'error_handlers': []
        }
    
    def set_auto_wire(self, enabled: bool) -> 'FactoryBuilder':
        """设置是否启用自动装配"""
        self._config['auto_wire_enabled'] = enabled
        return self
    
    def set_singleton_by_default(self, enabled: bool) -> 'FactoryBuilder':
        """设置是否默认使用单例"""
        self._config['singleton_by_default'] = enabled
        return self
    
    def set_lazy_loading(self, enabled: bool) -> 'FactoryBuilder':
        """设置是否启用懒加载"""
        self._config['enable_lazy_loading'] = enabled
        return self
    
    def set_circular_dependency_detection(self, enabled: bool, timeout: float = None) -> 'FactoryBuilder':
        """设置循环依赖检测"""
        self._config['enable_circular_dependency_detection'] = enabled
        if timeout is not None:
            self._config['circular_dependency_timeout'] = timeout
        return self
    
    def set_default_scope(self, scope: InstanceScope) -> 'FactoryBuilder':
        """设置默认作用域"""
        self._config['default_scope'] = scope
        return self
    
    def add_pre_creation_callback(self, callback: Callable) -> 'FactoryBuilder':
        """添加预创建回调"""
        self._callbacks['pre_creation'].append(callback)
        return self
    
    def add_post_creation_callback(self, callback: Callable) -> 'FactoryBuilder':
        """添加后创建回调"""
        self._callbacks['post_creation'].append(callback)
        return self
    
    def add_pre_destruction_callback(self, callback: Callable) -> 'FactoryBuilder':
        """添加预销毁回调"""
        self._callbacks['pre_destruction'].append(callback)
        return self
    
    def add_post_destruction_callback(self, callback: Callable) -> 'FactoryBuilder':
        """添加后销毁回调"""
        self._callbacks['post_destruction'].append(callback)
        return self
    
    def add_error_handler(self, handler: Callable) -> 'FactoryBuilder':
        """添加错误处理回调"""
        self._callbacks['error_handlers'].append(handler)
        return self
    
    def build(self, registry, dependency_resolver, config_manager=None) -> AutoWiringFactory:
        """构建工厂实例"""
        factory = AutoWiringFactory(registry, dependency_resolver, config_manager)
        
        # 应用配置
        for key, value in self._config.items():
            if hasattr(factory, key):
                setattr(factory, key, value)
        
        # 注册回调
        for callback in self._callbacks['pre_creation']:
            factory.add_pre_creation_callback(callback)
        
        for callback in self._callbacks['post_creation']:
            factory.add_post_creation_callback(callback)
        
        for callback in self._callbacks['pre_destruction']:
            factory.add_pre_destruction_callback(callback)
        
        for callback in self._callbacks['post_destruction']:
            factory.add_post_destruction_callback(callback)
        
        for handler in self._callbacks['error_handlers']:
            factory.add_error_handler(handler)
        
        return factory